"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ExplicitDependency_1 = __importDefault(require("./ExplicitDependency"));
const TopologicalSorter_1 = __importDefault(require("./TopologicalSorter"));
/**
 * A set of modules that can be queried for pertaining to a given subject.
 */
class ExplicitDependencySet {
    constructor(resolve, names) {
        this.resolve = resolve;
        this.dependencies = [];
        this.sortedBySubject = new Map();
        names.forEach((name) => this.add(name));
    }
    /**
     * Gets a list of ExplicitDependencies in this set which pertain to the
     * subject (that is, their `package.json` has a valid key for the subject
     * that indicates a requireable file). Detects dependencies between the
     * packages that pertain and sorts the list in dependency order.
     */
    pertaining(subject) {
        let sorted = this.sortedBySubject.get(subject);
        if (!sorted) {
            const pertaining = this.dependencies.filter((dependency) => dependency.pertains(subject));
            // Returns a list of dependents (not dependencies) of the supplied
            // dependency. This is the data structure needed for an efficient
            // topological sort.
            const getOutgoingEdges = (dependency) => pertaining.filter((dependent) => dependent !== dependency && dependent.dependsOn(dependency.name));
            const sorter = new TopologicalSorter_1.default(getOutgoingEdges);
            sorted = sorter.sort(pertaining);
            this.sortedBySubject.set(subject, sorted);
        }
        return sorted;
    }
    /**
     * Only add dependencies which can be resolved in the first place. If there
     * is a problem finding them, just skip them; they don't pertain!
     */
    add(name) {
        const modulePath = this.resolve(name);
        if (modulePath) {
            const dependency = new ExplicitDependency_1.default(modulePath);
            this.dependencies.push(dependency);
        }
    }
}
exports.default = ExplicitDependencySet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwbGljaXREZXBlbmRlbmN5U2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL0V4cGxpY2l0RGVwZW5kZW5jeVNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhFQUFzRDtBQUV0RCw0RUFBb0Q7QUFFcEQ7O0dBRUc7QUFDSCxNQUFxQixxQkFBcUI7SUFVeEMsWUFBWSxPQUFpQixFQUFFLEtBQWU7UUFDNUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2pDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVLENBQUMsT0FBZTtRQUMvQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxVQUFVLEdBQXlCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUMvRCxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FDN0MsQ0FBQztZQUNGLGtFQUFrRTtZQUNsRSxpRUFBaUU7WUFDakUsb0JBQW9CO1lBQ3BCLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxVQUE4QixFQUFFLEVBQUUsQ0FDMUQsVUFBVSxDQUFDLE1BQU0sQ0FDZixDQUFDLFNBQVMsRUFBRSxFQUFFLENBQ1osU0FBUyxLQUFLLFVBQVUsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FDbkUsQ0FBQztZQUNKLE1BQU0sTUFBTSxHQUFHLElBQUksMkJBQWlCLENBQ2xDLGdCQUFnQixDQUNqQixDQUFDO1lBQ0YsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzNDO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLEdBQUcsQ0FBQyxJQUFZO1FBQ3RCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxVQUFVLEVBQUU7WUFDZCxNQUFNLFVBQVUsR0FBRyxJQUFJLDRCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3RELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztDQUNGO0FBekRELHdDQXlEQyJ9