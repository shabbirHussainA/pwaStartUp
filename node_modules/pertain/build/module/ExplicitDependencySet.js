import ExplicitDependency from './ExplicitDependency';
import TopologicalSorter from './TopologicalSorter';
/**
 * A set of modules that can be queried for pertaining to a given subject.
 */
export default class ExplicitDependencySet {
    resolve;
    dependencies;
    /**
     * Cache storage to prevent unnecessary recalculation of the same list.
     * The same subject should result in the same list while this object exists.
     */
    sortedBySubject;
    constructor(resolve, names) {
        this.resolve = resolve;
        this.dependencies = [];
        this.sortedBySubject = new Map();
        names.forEach((name) => this.add(name));
    }
    /**
     * Gets a list of ExplicitDependencies in this set which pertain to the
     * subject (that is, their `package.json` has a valid key for the subject
     * that indicates a requireable file). Detects dependencies between the
     * packages that pertain and sorts the list in dependency order.
     */
    pertaining(subject) {
        let sorted = this.sortedBySubject.get(subject);
        if (!sorted) {
            const pertaining = this.dependencies.filter((dependency) => dependency.pertains(subject));
            // Returns a list of dependents (not dependencies) of the supplied
            // dependency. This is the data structure needed for an efficient
            // topological sort.
            const getOutgoingEdges = (dependency) => pertaining.filter((dependent) => dependent !== dependency && dependent.dependsOn(dependency.name));
            const sorter = new TopologicalSorter(getOutgoingEdges);
            sorted = sorter.sort(pertaining);
            this.sortedBySubject.set(subject, sorted);
        }
        return sorted;
    }
    /**
     * Only add dependencies which can be resolved in the first place. If there
     * is a problem finding them, just skip them; they don't pertain!
     */
    add(name) {
        const modulePath = this.resolve(name);
        if (modulePath) {
            const dependency = new ExplicitDependency(modulePath);
            this.dependencies.push(dependency);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwbGljaXREZXBlbmRlbmN5U2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL0V4cGxpY2l0RGVwZW5kZW5jeVNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLGtCQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBRXRELE9BQU8saUJBQWlCLE1BQU0scUJBQXFCLENBQUM7QUFFcEQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsT0FBTyxPQUFPLHFCQUFxQjtJQUNoQyxPQUFPLENBQVc7SUFDbEIsWUFBWSxDQUF1QjtJQUUzQzs7O09BR0c7SUFDSyxlQUFlLENBQW9DO0lBRTNELFlBQVksT0FBaUIsRUFBRSxLQUFlO1FBQzVDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNqQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksVUFBVSxDQUFDLE9BQWU7UUFDL0IsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sVUFBVSxHQUF5QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FDL0QsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQzdDLENBQUM7WUFDRixrRUFBa0U7WUFDbEUsaUVBQWlFO1lBQ2pFLG9CQUFvQjtZQUNwQixNQUFNLGdCQUFnQixHQUFHLENBQUMsVUFBOEIsRUFBRSxFQUFFLENBQzFELFVBQVUsQ0FBQyxNQUFNLENBQ2YsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUNaLFNBQVMsS0FBSyxVQUFVLElBQUksU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQ25FLENBQUM7WUFDSixNQUFNLE1BQU0sR0FBRyxJQUFJLGlCQUFpQixDQUNsQyxnQkFBZ0IsQ0FDakIsQ0FBQztZQUNGLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztTQUMzQztRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7O09BR0c7SUFDSyxHQUFHLENBQUMsSUFBWTtRQUN0QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RDLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxVQUFVLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN0RCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNwQztJQUNILENBQUM7Q0FDRiJ9